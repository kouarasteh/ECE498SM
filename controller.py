from __future__ import division
import matplotlib
from math import *
import numpy as np
from numpy import linalg as LA
import matplotlib.pyplot as plt
import argparse
from controller.model import model
from scipy.optimize import fsolve

V_R = 10.0

def controller(state, state_d):

	x, y, theta = state
	x_d, y_d = state_d
	localang = np.arctan((np.abs(y_d-y))/np.abs(x_d-x))
	if x_d <= x and y_d >= y:
		targ = np.pi - localang
	elif x_d >= x and y_d >= y:
		targ = localang
	elif x_d <= x and y_d <= y:
		targ = np.pi + localang
	elif x_d >= x and y_d <= y:
		targ = 2*np.pi - localang
	angdiff = (2*np.pi + targ - theta)%(2*np.pi)
	if angdiff < 0.0001:
		return(angdiff,10.0)
	return (angdiff,0.0)

def SELECT_INPUT(state, reach_state, obstacle_map = None, show_plot = False, time_steps = 1000):
	'''
	This will come up with a set of desired inputs such that the car drives from state ---> reach_state
	Input:
	state: current state of the car
	reach_state: the desired x,y position that you want the car to go
	obstacle_map: map of the world to check whether the path is safe or not
	show_plot: plotting the path generated by the controller (testing purposes only) keep this false
	time_steps: sanity check if the controller takes a long time then it breaks the loop
	Output:
	U: set of control inputs, data points along the pathway and other things that you think are necessary
	safe_check: whether the path computed by the controller is safe or not
	'''
	safe_check = True
	data = []
	U = []
	x, y, theta = state
	x_d, y_d= reach_state

	dist = np.sqrt((x - x_d)**2 + (y - y_d)**2)
	i = 0
	eps = 0.01
	while (dist>eps): #add relevant values in abs()
		i += 1

		data.append(state)

		if obstacle_map is not None:
			#obstacle_map = np.array(obstacle_map)
			if ((int(x) >= 1433) | (int(x) <= 0)  | ((int(y) >= 1069) | (int(y) <= 0))):
				safe_check = False
				break
			if (obstacle_map[int(x), int(y)] == (0, 0, 0)):	#(0, 0, 0)
				safe_check = False
				break
		if show_plot:
			print ('state:', state, 'iterations:', i)
			plt.plot(x, y, 'ro')

		x, y, theta = state
		control = controller(state, reach_state) # output two values one for steering and one for V_R
		U.append(control)
		# UPDATE MODEL
		state = model(state, control[0],control[1])
		dist = np.sqrt((x - x_d)**2 + (y - y_d)**2)

		if i > time_steps:
			safe_check = False
			break
	################################

	return U,safe_check

def test(state, reach_state):
	plt.plot([state[0], reach_state[0]], [state[1], reach_state[1]])
	SELECT_INPUT(state, reach_state, show_plot = True)
	plt.show()


# state = np.array([0, 0, 0.0])
# test(state, np.array([10,-100]))
